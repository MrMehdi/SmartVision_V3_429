; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\out\serialcom.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\serialcom.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\ST\STM32F4xx\Include -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSER_MSG_ENB -DWRITEIMAGEHEADER -DM16 -DSTM32F429_439xx --omf_browse=.\out\serialcom.crf ..\src\serialcom.c]
                          THUMB

                          AREA ||i.SerComCalculateUsedSpace||, CODE, READONLY, ALIGN=2

                  SerComCalculateUsedSpace PROC
;;;44     }
;;;45     u16 SerComCalculateUsedSpace(void)
000000  490d              LDR      r1,|L1.56|
;;;46     {
;;;47     	u16 sp;
;;;48     	//Calculate used space
;;;49     	if(uRxFullFlg == 0){
000002  7809              LDRB     r1,[r1,#0]  ; uRxFullFlg
000004  b9a9              CBNZ     r1,|L1.50|
;;;50     		if( uRxWp >= uRxRp)
000006  490d              LDR      r1,|L1.60|
000008  8809              LDRH     r1,[r1,#0]  ; uRxWp
00000a  4a0d              LDR      r2,|L1.64|
00000c  8812              LDRH     r2,[r2,#0]  ; uRxRp
00000e  4291              CMP      r1,r2
000010  db06              BLT      |L1.32|
;;;51     			sp = uRxWp - uRxRp;
000012  490a              LDR      r1,|L1.60|
000014  8809              LDRH     r1,[r1,#0]  ; uRxWp
000016  4a0a              LDR      r2,|L1.64|
000018  8812              LDRH     r2,[r2,#0]  ; uRxRp
00001a  1a89              SUBS     r1,r1,r2
00001c  b288              UXTH     r0,r1
00001e  e009              B        |L1.52|
                  |L1.32|
;;;52     		else
;;;53     			sp = USART_RX_BUFFER_SZ - uRxRp + uRxWp;
000020  4907              LDR      r1,|L1.64|
000022  8809              LDRH     r1,[r1,#0]  ; uRxRp
000024  f1c10120          RSB      r1,r1,#0x20
000028  4a04              LDR      r2,|L1.60|
00002a  8812              LDRH     r2,[r2,#0]  ; uRxWp
00002c  4411              ADD      r1,r1,r2
00002e  b288              UXTH     r0,r1
000030  e000              B        |L1.52|
                  |L1.50|
;;;54     	}
;;;55     	else{
;;;56     			sp = USART_RX_BUFFER_SZ;
000032  2020              MOVS     r0,#0x20
                  |L1.52|
;;;57     	}
;;;58     	return sp;
;;;59     }
000034  4770              BX       lr
;;;60     
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      uRxFullFlg
                  |L1.60|
                          DCD      uRxWp
                  |L1.64|
                          DCD      uRxRp

                          AREA ||i.SerComConfig||, CODE, READONLY, ALIGN=2

                  SerComConfig PROC
;;;285    
;;;286    void SerComConfig(void)
000000  b500              PUSH     {lr}
;;;287    {
000002  b087              SUB      sp,sp,#0x1c
;;;288    	
;;;289    	
;;;290    	//CAMTXRX is link between NORDIC and STM
;;;291    	//STMTXRX is link between STM32 and PC
;;;292    	
;;;293    	//STMTX - UART7TX - PE8 - PIN39
;;;294    	//STMRX - UART7RX - PE7 - PIN38
;;;295    	
;;;296    	
;;;297    	USART_InitTypeDef USART_InitStructure;
;;;298    
;;;299    	GPIO_InitTypeDef GPIO_InitStructure;
;;;300    	NVIC_InitTypeDef NVIC_InitStructure;
;;;301    	
;;;302    	//CONFIGURE NORDIC-STM UART
;;;303    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);//A2 A3
000004  2101              MOVS     r1,#1
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;304    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);	
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;305    	
;;;306    		/* Configure USART Tx as alternate function  */
;;;307    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
000014  200c              MOVS     r0,#0xc
000016  9001              STR      r0,[sp,#4]
;;;308    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000018  2002              MOVS     r0,#2
00001a  f88d0008          STRB     r0,[sp,#8]
;;;309    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001e  2000              MOVS     r0,#0
000020  f88d000a          STRB     r0,[sp,#0xa]
;;;310    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2002              MOVS     r0,#2
000026  f88d0009          STRB     r0,[sp,#9]
;;;311    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
00002a  2001              MOVS     r0,#1
00002c  f88d000b          STRB     r0,[sp,#0xb]
;;;312    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000030  a901              ADD      r1,sp,#4
000032  483e              LDR      r0,|L2.300|
000034  f7fffffe          BL       GPIO_Init
;;;313    	
;;;314    	/* Connect PXx to USARTx_Tx*/
;;;315    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
000038  2207              MOVS     r2,#7
00003a  2102              MOVS     r1,#2
00003c  483b              LDR      r0,|L2.300|
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;316     	/* Connect PXx to USARTx_Rx*/
;;;317    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
000042  2207              MOVS     r2,#7
000044  2103              MOVS     r1,#3
000046  4839              LDR      r0,|L2.300|
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;318    	
;;;319    	USART_InitStructure.USART_BaudRate = 115200;
00004c  f44f30e1          MOV      r0,#0x1c200
000050  9003              STR      r0,[sp,#0xc]
;;;320    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000052  2000              MOVS     r0,#0
000054  f8ad0010          STRH     r0,[sp,#0x10]
;;;321    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000058  f8ad0012          STRH     r0,[sp,#0x12]
;;;322    	USART_InitStructure.USART_Parity = USART_Parity_No;
00005c  f8ad0014          STRH     r0,[sp,#0x14]
;;;323    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000060  f8ad0018          STRH     r0,[sp,#0x18]
;;;324    	USART_InitStructure.USART_Mode =USART_Mode_Rx | USART_Mode_Tx;/* Connect PXx to USARTx_Rx*/
000064  200c              MOVS     r0,#0xc
000066  f8ad0016          STRH     r0,[sp,#0x16]
;;;325    	USART_Init(USART2, &USART_InitStructure);
00006a  a903              ADD      r1,sp,#0xc
00006c  4830              LDR      r0,|L2.304|
00006e  f7fffffe          BL       USART_Init
;;;326    
;;;327    	//Configure interupt on RX
;;;328    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); 	
000072  2201              MOVS     r2,#1
000074  f2405125          MOV      r1,#0x525
000078  482d              LDR      r0,|L2.304|
00007a  f7fffffe          BL       USART_ITConfig
;;;329    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;		 // we want to configure the USART2 interrupts
00007e  2026              MOVS     r0,#0x26
000080  f88d0000          STRB     r0,[sp,#0]
;;;330    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // this sets the priority group of the USART3interrupts
000084  2000              MOVS     r0,#0
000086  f88d0001          STRB     r0,[sp,#1]
;;;331    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		  // this sets the subpriority inside the group
00008a  f88d0002          STRB     r0,[sp,#2]
;;;332    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			  // the USART1 interrupts are globally enabled
00008e  2001              MOVS     r0,#1
000090  f88d0003          STRB     r0,[sp,#3]
;;;333    	NVIC_Init(&NVIC_InitStructure);	
000094  4668              MOV      r0,sp
000096  f7fffffe          BL       NVIC_Init
;;;334    	
;;;335    	/* Enable USART */
;;;336    	USART_Cmd(USART2, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  4824              LDR      r0,|L2.304|
00009e  f7fffffe          BL       USART_Cmd
;;;337    	
;;;338    	Delayms(1);
0000a2  2001              MOVS     r0,#1
0000a4  f7fffffe          BL       Delayms
;;;339    	//CONFIGURE STM-PC UART
;;;340    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART7, ENABLE);//E7 E8
0000a8  2101              MOVS     r1,#1
0000aa  0788              LSLS     r0,r1,#30
0000ac  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;341    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);		
0000b0  2101              MOVS     r1,#1
0000b2  2010              MOVS     r0,#0x10
0000b4  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;342    	
;;;343    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8;
0000b8  f44f70c0          MOV      r0,#0x180
0000bc  9001              STR      r0,[sp,#4]
;;;344    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000be  2002              MOVS     r0,#2
0000c0  f88d0008          STRB     r0,[sp,#8]
;;;345    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000c4  2000              MOVS     r0,#0
0000c6  f88d000a          STRB     r0,[sp,#0xa]
;;;346    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000ca  2002              MOVS     r0,#2
0000cc  f88d0009          STRB     r0,[sp,#9]
;;;347    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
0000d0  2001              MOVS     r0,#1
0000d2  f88d000b          STRB     r0,[sp,#0xb]
;;;348    
;;;349    	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000d6  a901              ADD      r1,sp,#4
0000d8  4816              LDR      r0,|L2.308|
0000da  f7fffffe          BL       GPIO_Init
;;;350    	
;;;351    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_UART7);
0000de  2208              MOVS     r2,#8
0000e0  4611              MOV      r1,r2
0000e2  4814              LDR      r0,|L2.308|
0000e4  f7fffffe          BL       GPIO_PinAFConfig
;;;352    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_UART7);
0000e8  2208              MOVS     r2,#8
0000ea  2107              MOVS     r1,#7
0000ec  4811              LDR      r0,|L2.308|
0000ee  f7fffffe          BL       GPIO_PinAFConfig
;;;353     	
;;;354    	USART_InitStructure.USART_BaudRate = 115200;
0000f2  f44f30e1          MOV      r0,#0x1c200
0000f6  9003              STR      r0,[sp,#0xc]
;;;355    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000f8  2000              MOVS     r0,#0
0000fa  f8ad0010          STRH     r0,[sp,#0x10]
;;;356    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000fe  f8ad0012          STRH     r0,[sp,#0x12]
;;;357    	USART_InitStructure.USART_Parity = USART_Parity_No;
000102  f8ad0014          STRH     r0,[sp,#0x14]
;;;358    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000106  f8ad0018          STRH     r0,[sp,#0x18]
;;;359    	USART_InitStructure.USART_Mode =USART_Mode_Rx | USART_Mode_Tx;/* Connect PXx to USARTx_Rx*/
00010a  200c              MOVS     r0,#0xc
00010c  f8ad0016          STRH     r0,[sp,#0x16]
;;;360    	USART_Init(UART7, &USART_InitStructure);
000110  a903              ADD      r1,sp,#0xc
000112  4809              LDR      r0,|L2.312|
000114  f7fffffe          BL       USART_Init
;;;361    
;;;362      
;;;363    	/* Enable USART */
;;;364    	USART_Cmd(UART7, ENABLE);
000118  2101              MOVS     r1,#1
00011a  4807              LDR      r0,|L2.312|
00011c  f7fffffe          BL       USART_Cmd
;;;365    	Delayms(1);
000120  2001              MOVS     r0,#1
000122  f7fffffe          BL       Delayms
;;;366    }
000126  b007              ADD      sp,sp,#0x1c
000128  bd00              POP      {pc}
                          ENDP

00012a  0000              DCW      0x0000
                  |L2.300|
                          DCD      0x40020000
                  |L2.304|
                          DCD      0x40004400
                  |L2.308|
                          DCD      0x40021000
                  |L2.312|
                          DCD      0x40007800

                          AREA ||i.SerComParseByte||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SerComParseByte PROC
;;;119    
;;;120    void SerComParseByte(u8* b,u16 sz)
000000  b530              PUSH     {r4,r5,lr}
;;;121    {
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;122    	u8 sb[30];
;;;123    	u8 cb[30];
;;;124    	camera_setting cs;
;;;125    	u8 JpegBuffer[4];u32 i,k;
;;;126    	u32 flash_img_sz=0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;127    	u32 nseq=0;
00000c  9001              STR      r0,[sp,#4]
;;;128    	
;;;129    	switch(b[0])
00000e  7820              LDRB     r0,[r4,#0]
000010  280d              CMP      r0,#0xd
000012  d27c              BCS      |L3.270|
000014  e8dff000          TBB      [pc,r0]
000018  a307a39f          DCB      0xa3,0x07,0xa3,0x9f
00001c  4c999a9e          DCB      0x4c,0x99,0x9a,0x9e
000020  627c7d5a          DCB      0x62,0x7c,0x7d,0x5a
000024  5d00              DCB      0x5d,0x00
;;;130    	{
;;;131    		
;;;132    		case 0x01: //take picture
;;;133    			
;;;134    		  if(sz > 1)goto err_com;
000026  2d01              CMP      r5,#1
000028  dd00              BLE      |L3.44|
00002a  e09c              B        |L3.358|
                  |L3.44|
;;;135    		  
;;;136    			//Flash_Read(FLASH_CAM_SETTING_ADD,(void*)&cs,sizeof(cs));//read camera settings from internal flash
;;;137    			
;;;138    			cb[0] = Cam_click_images(cs.cdly,&nseq,&flash_img_sz);//click images;
00002c  f8bd001a          LDRH     r0,[sp,#0x1a]
000030  aa02              ADD      r2,sp,#8
000032  a901              ADD      r1,sp,#4
000034  f7fffffe          BL       Cam_click_images
000038  f88d0024          STRB     r0,[sp,#0x24]
;;;139    			
;;;140    			SerComSendRsp(1,cb,1);	//report failure of image acquisition to PC
00003c  2201              MOVS     r2,#1
00003e  a909              ADD      r1,sp,#0x24
000040  4610              MOV      r0,r2
000042  f7fffffe          BL       SerComSendRsp
;;;141    	
;;;142    			//store image to flash here
;;;143    			
;;;144    			SerComSendMessageUser("Total Image's Size ");
000046  a04a              ADR      r0,|L3.368|
000048  f7fffffe          BL       SerComSendMessageUser
;;;145    			sprintf((void*)sb,"%d Kbytes \r\n",flash_img_sz/1024);
00004c  9802              LDR      r0,[sp,#8]
00004e  0a82              LSRS     r2,r0,#10
000050  a14c              ADR      r1,|L3.388|
000052  a811              ADD      r0,sp,#0x44
000054  f7fffffe          BL       __2sprintf
;;;146    			SerComSendMessageUser(sb);
000058  a811              ADD      r0,sp,#0x44
00005a  f7fffffe          BL       SerComSendMessageUser
;;;147    
;;;148    			
;;;149    			cb[4] = (unsigned char) (nseq >>24);
00005e  9801              LDR      r0,[sp,#4]
000060  0e00              LSRS     r0,r0,#24
000062  f88d0028          STRB     r0,[sp,#0x28]
;;;150    			cb[5] = (unsigned char) (nseq >>16);
000066  9801              LDR      r0,[sp,#4]
000068  0c00              LSRS     r0,r0,#16
00006a  f88d0029          STRB     r0,[sp,#0x29]
;;;151    			cb[6] = (unsigned char) (nseq >> 8);
00006e  9801              LDR      r0,[sp,#4]
000070  0a00              LSRS     r0,r0,#8
000072  f88d002a          STRB     r0,[sp,#0x2a]
;;;152    			cb[7] = (unsigned char) (nseq >> 0);
000076  9801              LDR      r0,[sp,#4]
000078  b2c0              UXTB     r0,r0
00007a  f88d002b          STRB     r0,[sp,#0x2b]
;;;153    			
;;;154    			cb[0] = (unsigned char) (flash_img_sz >>24);
00007e  9802              LDR      r0,[sp,#8]
000080  0e00              LSRS     r0,r0,#24
000082  f88d0024          STRB     r0,[sp,#0x24]
;;;155    			cb[1] = (unsigned char) (flash_img_sz >>16);
000086  9802              LDR      r0,[sp,#8]
000088  0c00              LSRS     r0,r0,#16
00008a  f88d0025          STRB     r0,[sp,#0x25]
;;;156    			cb[2] = (unsigned char) (flash_img_sz >> 8);
00008e  9802              LDR      r0,[sp,#8]
000090  0a00              LSRS     r0,r0,#8
000092  f88d0026          STRB     r0,[sp,#0x26]
;;;157    			cb[3] = (unsigned char) (flash_img_sz >> 0);
000096  9802              LDR      r0,[sp,#8]
000098  b2c0              UXTB     r0,r0
00009a  f88d0027          STRB     r0,[sp,#0x27]
;;;158    			
;;;159    			SerComSendRsp(2,(void*)cb,8);//send response
00009e  2208              MOVS     r2,#8
0000a0  a909              ADD      r1,sp,#0x24
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       SerComSendRsp
;;;160    			Cam_LED(DISABLE);
0000a8  2000              MOVS     r0,#0
0000aa  f7fffffe          BL       Cam_LED
;;;161    			
;;;162    		break;
0000ae  e057              B        |L3.352|
;;;163    			
;;;164    		case 0x04:
;;;165    			if(sz != 2)goto err_com;
0000b0  2d02              CMP      r5,#2
0000b2  d000              BEQ      |L3.182|
0000b4  e057              B        |L3.358|
                  |L3.182|
;;;166    		
;;;167    			if(b[1] < FTB_FILES_TOTAL)
0000b6  7860              LDRB     r0,[r4,#1]
0000b8  2804              CMP      r0,#4
0000ba  da03              BGE      |L3.196|
;;;168    			{
;;;169    				Flash_dump_imagedata(b[1]);
0000bc  7860              LDRB     r0,[r4,#1]
0000be  f7fffffe          BL       Flash_dump_imagedata
0000c2  e002              B        |L3.202|
                  |L3.196|
;;;170    			}
;;;171    			else
;;;172    			{
;;;173    				SerComSendMessageUser("File no doesnt Exist\r\n");
0000c4  a033              ADR      r0,|L3.404|
0000c6  f7fffffe          BL       SerComSendMessageUser
                  |L3.202|
;;;174    			}
;;;175    		break;
0000ca  e049              B        |L3.352|
;;;176    		case 0x0b: // Display File Table
;;;177    			 Flash_Dump_filetable();
0000cc  f7fffffe          BL       Flash_Dump_filetable
;;;178    		break;
0000d0  e046              B        |L3.352|
;;;179    		case 0x0c: // Display File Table
;;;180    			Flash_Create_FS();
0000d2  f7fffffe          BL       Flash_Create_FS
;;;181    			Flash_Dump_filetable();
0000d6  f7fffffe          BL       Flash_Dump_filetable
;;;182    		break;
0000da  e041              B        |L3.352|
;;;183    		case 0x08:
;;;184    			SerComSendMessageUser("Loading Default Settings\r\n");
0000dc  a033              ADR      r0,|L3.428|
0000de  f7fffffe          BL       SerComSendMessageUser
;;;185    			CamApi_load_default_settings(&cs);
0000e2  a803              ADD      r0,sp,#0xc
0000e4  f7fffffe          BL       CamApi_load_default_settings
;;;186    			cs.header = 0x01ABCDEF;
0000e8  4837              LDR      r0,|L3.456|
0000ea  9003              STR      r0,[sp,#0xc]
;;;187    			SerComSendMessageUser("Storing Settings to Flash\r\n");
0000ec  a037              ADR      r0,|L3.460|
0000ee  f7fffffe          BL       SerComSendMessageUser
;;;188    			cb[0] = Flash_Write(FLASH_CAM_SETTING_ADD,(void*)&cs,sizeof(cs));
0000f2  2218              MOVS     r2,#0x18
0000f4  a903              ADD      r1,sp,#0xc
0000f6  f44f207f          MOV      r0,#0xff000
0000fa  f7fffffe          BL       Flash_Write
0000fe  f88d0024          STRB     r0,[sp,#0x24]
;;;189    			SerComSendRsp(8,cb,1);	
000102  2201              MOVS     r2,#1
000104  a909              ADD      r1,sp,#0x24
000106  2008              MOVS     r0,#8
000108  f7fffffe          BL       SerComSendRsp
;;;190    		break;
00010c  e028              B        |L3.352|
                  |L3.270|
00010e  e026              B        |L3.350|
;;;191    		
;;;192    		case 0x09:
;;;193    //			SerComSendMessageUser("Initializing Camera registers\r\n");
;;;194    //			cb[0] |= Cam_Init_Registers(&cs);//Initialize both camera registers to prepare for click,both cameras in power down state on return
;;;195    //			SerComSendRsp(9,cb,1);
;;;196    		break;
000110  e026              B        |L3.352|
;;;197    		
;;;198    		case 0x0a:
;;;199    			SerComSendMessageUser("Rebooting\r\n");
000112  a035              ADR      r0,|L3.488|
000114  f7fffffe          BL       SerComSendMessageUser
;;;200    			cb[0] = 0;
000118  2000              MOVS     r0,#0
00011a  f88d0024          STRB     r0,[sp,#0x24]
;;;201    			SerComSendRsp(10,cb,1);
00011e  2201              MOVS     r2,#1
000120  a909              ADD      r1,sp,#0x24
000122  200a              MOVS     r0,#0xa
000124  f7fffffe          BL       SerComSendRsp
;;;202    			NVIC_SystemReset();
000128  bf00              NOP      
00012a  f3bf8f4f          DSB      
00012e  4831              LDR      r0,|L3.500|
000130  6800              LDR      r0,[r0,#0]
000132  f40060e0          AND      r0,r0,#0x700
000136  4930              LDR      r1,|L3.504|
000138  4308              ORRS     r0,r0,r1
00013a  1d00              ADDS     r0,r0,#4
00013c  492d              LDR      r1,|L3.500|
00013e  6008              STR      r0,[r1,#0]
000140  f3bf8f4f          DSB      
000144  bf00              NOP      
000146  bf00              NOP      
                  |L3.328|
000148  e7fe              B        |L3.328|
;;;203    		break;
;;;204    		case 0x05://write camera settings
;;;205    			goto err_com;
00014a  e00c              B        |L3.358|
;;;206    			if(sz != 7)goto err_com;
;;;207    			
;;;208    		
;;;209    		break;	
;;;210    		case 0x06://read camera settings
;;;211    			if(sz > 1)goto err_com;
00014c  2d01              CMP      r5,#1
00014e  dd00              BLE      |L3.338|
000150  e009              B        |L3.358|
                  |L3.338|
;;;212          goto err_com;
000152  e008              B        |L3.358|
;;;213    			
;;;214    		break;	
;;;215    		case 0x07: //request Firmware revision
;;;216    			
;;;217    		break;
000154  e004              B        |L3.352|
;;;218    		case 0x03: //request image block //No longer supported
;;;219    				SerComSendMessageUser("Not Supported\r\n");
000156  a029              ADR      r0,|L3.508|
000158  f7fffffe          BL       SerComSendMessageUser
;;;220    				goto err_com;
00015c  e003              B        |L3.358|
                  |L3.350|
;;;221    
;;;222    		break;
;;;223    		
;;;224    		default:
;;;225    			goto err_com;
00015e  e002              B        |L3.358|
                  |L3.352|
000160  bf00              NOP                            ;162
                  |L3.354|
;;;226    			break;
;;;227    	}
;;;228    return;
;;;229    	
;;;230    	err_com:
;;;231    	SerComSendMessageUser("Invalid Command or ECHO was sent\r\n");
;;;232    	//cb[0] = 0x0A;//Invalid command response
;;;233    	//SerComSendRsp(b[0],(void*)cb,1);//send response
;;;234    	
;;;235    }
000162  b019              ADD      sp,sp,#0x64
000164  bd30              POP      {r4,r5,pc}
                  |L3.358|
000166  a029              ADR      r0,|L3.524|
000168  f7fffffe          BL       SerComSendMessageUser
00016c  bf00              NOP      
00016e  e7f8              B        |L3.354|
;;;236    
                          ENDP

                  |L3.368|
000170  546f7461          DCB      "Total Image's Size ",0
000174  6c20496d
000178  61676527
00017c  73205369
000180  7a652000
                  |L3.388|
000184  2564204b          DCB      "%d Kbytes \r\n",0
000188  62797465
00018c  73200d0a
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L3.404|
000194  46696c65          DCB      "File no doesnt Exist\r\n",0
000198  206e6f20
00019c  646f6573
0001a0  6e742045
0001a4  78697374
0001a8  0d0a00  
0001ab  00                DCB      0
                  |L3.428|
0001ac  4c6f6164          DCB      "Loading Default Settings\r\n",0
0001b0  696e6720
0001b4  44656661
0001b8  756c7420
0001bc  53657474
0001c0  696e6773
0001c4  0d0a00  
0001c7  00                DCB      0
                  |L3.456|
                          DCD      0x01abcdef
                  |L3.460|
0001cc  53746f72          DCB      "Storing Settings to Flash\r\n",0
0001d0  696e6720
0001d4  53657474
0001d8  696e6773
0001dc  20746f20
0001e0  466c6173
0001e4  680d0a00
                  |L3.488|
0001e8  5265626f          DCB      "Rebooting\r\n",0
0001ec  6f74696e
0001f0  670d0a00
                  |L3.500|
                          DCD      0xe000ed0c
                  |L3.504|
                          DCD      0x05fa0000
                  |L3.508|
0001fc  4e6f7420          DCB      "Not Supported\r\n",0
000200  53757070
000204  6f727465
000208  640d0a00
                  |L3.524|
00020c  496e7661          DCB      "Invalid Command or ECHO was sent\r\n",0
000210  6c696420
000214  436f6d6d
000218  616e6420
00021c  6f722045
000220  43484f20
000224  77617320
000228  73656e74
00022c  0d0a00  
00022f  00                DCB      0

                          AREA ||i.SerComProcess||, CODE, READONLY, ALIGN=2

                  SerComProcess PROC
;;;60     
;;;61     void SerComProcess(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;62     {
;;;63     	u16 used;
;;;64     	u16 i,j,k;
;;;65     	used = SerComCalculateUsedSpace();
000004  f7fffffe          BL       SerComCalculateUsedSpace
000008  4607              MOV      r7,r0
;;;66     	
;;;67     	if( used > 4 ){
00000a  2f04              CMP      r7,#4
00000c  dd67              BLE      |L4.222|
;;;68     		for( i = 0;i < used; i++)
00000e  2400              MOVS     r4,#0
000010  e063              B        |L4.218|
                  |L4.18|
;;;69     		{
;;;70     			if ( uRxData[ (uRxRp + i +0) & USART_RX_BUFFER_SZ-1] == 0xFF	&&
000012  483e              LDR      r0,|L4.268|
000014  8800              LDRH     r0,[r0,#0]  ; uRxRp
000016  4420              ADD      r0,r0,r4
000018  f000001f          AND      r0,r0,#0x1f
00001c  493c              LDR      r1,|L4.272|
00001e  5c08              LDRB     r0,[r1,r0]
000020  28ff              CMP      r0,#0xff
000022  d158              BNE      |L4.214|
;;;71     					 uRxData[ (uRxRp + i +1) & USART_RX_BUFFER_SZ-1] == 0xFE ){//Header
000024  4839              LDR      r0,|L4.268|
000026  8800              LDRH     r0,[r0,#0]  ; uRxRp
000028  4420              ADD      r0,r0,r4
00002a  1c40              ADDS     r0,r0,#1
00002c  f000001f          AND      r0,r0,#0x1f
000030  5c08              LDRB     r0,[r1,r0]
000032  28fe              CMP      r0,#0xfe
000034  d14f              BNE      |L4.214|
;;;72     							for(j = i + 2;j<used-1; j++){
000036  1ca0              ADDS     r0,r4,#2
000038  b285              UXTH     r5,r0
00003a  e048              B        |L4.206|
                  |L4.60|
;;;73     								if ( uRxData[ (uRxRp + j +0) & USART_RX_BUFFER_SZ-1] == 0xFF	&&
00003c  4833              LDR      r0,|L4.268|
00003e  8800              LDRH     r0,[r0,#0]  ; uRxRp
000040  4428              ADD      r0,r0,r5
000042  f000001f          AND      r0,r0,#0x1f
000046  4932              LDR      r1,|L4.272|
000048  5c08              LDRB     r0,[r1,r0]
00004a  28ff              CMP      r0,#0xff
00004c  d13d              BNE      |L4.202|
;;;74     										 uRxData[ (uRxRp + j +1) & USART_RX_BUFFER_SZ-1] == 0xFA ){//Footer
00004e  482f              LDR      r0,|L4.268|
000050  8800              LDRH     r0,[r0,#0]  ; uRxRp
000052  4428              ADD      r0,r0,r5
000054  1c40              ADDS     r0,r0,#1
000056  f000001f          AND      r0,r0,#0x1f
00005a  5c08              LDRB     r0,[r1,r0]
00005c  28fa              CMP      r0,#0xfa
00005e  d134              BNE      |L4.202|
;;;75     											 if( j-i-2 < COM_MAX_SZ){
000060  1b28              SUBS     r0,r5,r4
000062  1e80              SUBS     r0,r0,#2
000064  2814              CMP      r0,#0x14
000066  da24              BGE      |L4.178|
;;;76     												 for(k=0;k<j-i-2;k++){
000068  2600              MOVS     r6,#0
00006a  e00c              B        |L4.134|
                  |L4.108|
;;;77     													 rxdata[k] = uRxData[ (uRxRp + i + k + 2) & USART_RX_BUFFER_SZ-1];//store message for further processing
00006c  4827              LDR      r0,|L4.268|
00006e  8800              LDRH     r0,[r0,#0]  ; uRxRp
000070  4420              ADD      r0,r0,r4
000072  4430              ADD      r0,r0,r6
000074  1c80              ADDS     r0,r0,#2
000076  f000001f          AND      r0,r0,#0x1f
00007a  4925              LDR      r1,|L4.272|
00007c  5c08              LDRB     r0,[r1,r0]
00007e  4925              LDR      r1,|L4.276|
000080  5588              STRB     r0,[r1,r6]
000082  1c70              ADDS     r0,r6,#1              ;76
000084  b286              UXTH     r6,r0                 ;76
                  |L4.134|
000086  1b28              SUBS     r0,r5,r4              ;76
000088  1e80              SUBS     r0,r0,#2              ;76
00008a  42b0              CMP      r0,r6                 ;76
00008c  dcee              BGT      |L4.108|
;;;78     												 }
;;;79     												 uRxRp += (j + 2);//Increment read pointer
00008e  481f              LDR      r0,|L4.268|
000090  8801              LDRH     r1,[r0,#0]  ; uRxRp
000092  1ca8              ADDS     r0,r5,#2
000094  4408              ADD      r0,r0,r1
000096  491d              LDR      r1,|L4.268|
000098  8008              STRH     r0,[r1,#0]
;;;80     												 uRxRp &= USART_RX_BUFFER_SZ-1;
00009a  4608              MOV      r0,r1
00009c  8800              LDRH     r0,[r0,#0]  ; uRxRp
00009e  f000001f          AND      r0,r0,#0x1f
0000a2  8008              STRH     r0,[r1,#0]
;;;81     												 SerComParseByte(rxdata,j-i-2);//Parse this message
0000a4  1b28              SUBS     r0,r5,r4
0000a6  1e80              SUBS     r0,r0,#2
0000a8  b281              UXTH     r1,r0
0000aa  481a              LDR      r0,|L4.276|
0000ac  f7fffffe          BL       SerComParseByte
0000b0  e00a              B        |L4.200|
                  |L4.178|
;;;82     											 }
;;;83     											 else
;;;84     											 {
;;;85     													uRxRp += (j + 2);//Increment read pointer only too large message
0000b2  4816              LDR      r0,|L4.268|
0000b4  8801              LDRH     r1,[r0,#0]  ; uRxRp
0000b6  1ca8              ADDS     r0,r5,#2
0000b8  4408              ADD      r0,r0,r1
0000ba  4914              LDR      r1,|L4.268|
0000bc  8008              STRH     r0,[r1,#0]
;;;86     													uRxRp &= USART_RX_BUFFER_SZ-1;
0000be  4608              MOV      r0,r1
0000c0  8800              LDRH     r0,[r0,#0]  ; uRxRp
0000c2  f000001f          AND      r0,r0,#0x1f
0000c6  8008              STRH     r0,[r1,#0]
                  |L4.200|
;;;87     											 }
;;;88     											 break;
0000c8  e004              B        |L4.212|
                  |L4.202|
0000ca  1c68              ADDS     r0,r5,#1              ;72
0000cc  b285              UXTH     r5,r0                 ;72
                  |L4.206|
0000ce  1e78              SUBS     r0,r7,#1              ;72
0000d0  42a8              CMP      r0,r5                 ;72
0000d2  dcb3              BGT      |L4.60|
                  |L4.212|
0000d4  bf00              NOP      
                  |L4.214|
0000d6  1c60              ADDS     r0,r4,#1              ;68
0000d8  b284              UXTH     r4,r0                 ;68
                  |L4.218|
0000da  42bc              CMP      r4,r7                 ;68
0000dc  db99              BLT      |L4.18|
                  |L4.222|
;;;89     								}															 
;;;90     							}
;;;91     				 }											 
;;;92     		}
;;;93     	}
;;;94     	
;;;95     	if( uRxFullFlg )//No command recieved empty full buffer
0000de  480e              LDR      r0,|L4.280|
0000e0  7800              LDRB     r0,[r0,#0]  ; uRxFullFlg
0000e2  b130              CBZ      r0,|L4.242|
;;;96     		uRxWp = uRxRp = uRxFullFlg = 0;
0000e4  2000              MOVS     r0,#0
0000e6  490c              LDR      r1,|L4.280|
0000e8  7008              STRB     r0,[r1,#0]
0000ea  4908              LDR      r1,|L4.268|
0000ec  8008              STRH     r0,[r1,#0]
0000ee  490b              LDR      r1,|L4.284|
0000f0  8008              STRH     r0,[r1,#0]
                  |L4.242|
;;;97     
;;;98     	
;;;99     		
;;;100    	if(uRxRp > USART_RX_BUFFER_SZ-1){
0000f2  4806              LDR      r0,|L4.268|
0000f4  8800              LDRH     r0,[r0,#0]  ; uRxRp
0000f6  281f              CMP      r0,#0x1f
0000f8  dd02              BLE      |L4.256|
;;;101    		uRxRp = 0;//Wrap around
0000fa  2000              MOVS     r0,#0
0000fc  4903              LDR      r1,|L4.268|
0000fe  8008              STRH     r0,[r1,#0]
                  |L4.256|
;;;102    	}
;;;103    	uRxFullFlg = 0;
000100  2000              MOVS     r0,#0
000102  4905              LDR      r1,|L4.280|
000104  7008              STRB     r0,[r1,#0]
;;;104    		
;;;105    }
000106  e8bd81f0          POP      {r4-r8,pc}
;;;106    
                          ENDP

00010a  0000              DCW      0x0000
                  |L4.268|
                          DCD      uRxRp
                  |L4.272|
                          DCD      uRxData
                  |L4.276|
                          DCD      rxdata
                  |L4.280|
                          DCD      uRxFullFlg
                  |L4.284|
                          DCD      uRxWp

                          AREA ||i.SerComSendArr||, CODE, READONLY, ALIGN=1

                  SerComSendArr PROC
;;;247    
;;;248    void SerComSendArr(u8* b, u32 n){
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;249    	u16 i = 0;
000006  2600              MOVS     r6,#0
;;;250    	while(n>0){
000008  e005              B        |L5.22|
                  |L5.10|
;;;251    		SerComSendByte(b[i]);
00000a  5da8              LDRB     r0,[r5,r6]
00000c  f7fffffe          BL       SerComSendByte
;;;252    		n--;
000010  1e64              SUBS     r4,r4,#1
;;;253    		i++;
000012  1c70              ADDS     r0,r6,#1
000014  b286              UXTH     r6,r0
                  |L5.22|
000016  2c00              CMP      r4,#0                 ;250
000018  d1f7              BNE      |L5.10|
;;;254    	}
;;;255    }
00001a  bd70              POP      {r4-r6,pc}
;;;256    
                          ENDP


                          AREA ||i.SerComSendArrayUser||, CODE, READONLY, ALIGN=2

                  SerComSendArrayUser PROC
;;;265    //}
;;;266    void SerComSendArrayUser(u8* b,u32 n)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;268    	while(n)
000006  e013              B        |L6.48|
                  |L6.8|
;;;269    	{
;;;270    		while (USART_GetFlagStatus(UART7, USART_FLAG_TC) == 0);
000008  bf00              NOP      
                  |L6.10|
00000a  2140              MOVS     r1,#0x40
00000c  480a              LDR      r0,|L6.56|
00000e  f7fffffe          BL       USART_GetFlagStatus
000012  2800              CMP      r0,#0
000014  d0f9              BEQ      |L6.10|
;;;271    		USART_SendData(UART7,*b);
000016  7821              LDRB     r1,[r4,#0]
000018  4807              LDR      r0,|L6.56|
00001a  f7fffffe          BL       USART_SendData
;;;272    		while (USART_GetFlagStatus(UART7, USART_FLAG_TC) == 0);
00001e  bf00              NOP      
                  |L6.32|
000020  2140              MOVS     r1,#0x40
000022  4805              LDR      r0,|L6.56|
000024  f7fffffe          BL       USART_GetFlagStatus
000028  2800              CMP      r0,#0
00002a  d0f9              BEQ      |L6.32|
;;;273    		b++;n--;
00002c  1c64              ADDS     r4,r4,#1
00002e  1e6d              SUBS     r5,r5,#1
                  |L6.48|
000030  2d00              CMP      r5,#0                 ;268
000032  d1e9              BNE      |L6.8|
;;;274    	}
;;;275    }
000034  bd70              POP      {r4-r6,pc}
;;;276    void SerComSendMessageUser(const u8 * s){
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40007800

                          AREA ||i.SerComSendByte||, CODE, READONLY, ALIGN=2

                  SerComSendByte PROC
;;;236    
;;;237    void SerComSendByte(u8 b){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;238    	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == 0);
000004  bf00              NOP      
                  |L7.6|
000006  2140              MOVS     r1,#0x40
000008  4808              LDR      r0,|L7.44|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L7.6|
;;;239    	USART_SendData(USART2,b);
000012  4621              MOV      r1,r4
000014  4805              LDR      r0,|L7.44|
000016  f7fffffe          BL       USART_SendData
;;;240    	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == 0);
00001a  bf00              NOP      
                  |L7.28|
00001c  2140              MOVS     r1,#0x40
00001e  4803              LDR      r0,|L7.44|
000020  f7fffffe          BL       USART_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L7.28|
;;;241    }
000028  bd10              POP      {r4,pc}
;;;242    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40004400

                          AREA ||i.SerComSendMessageUser||, CODE, READONLY, ALIGN=2

                  SerComSendMessageUser PROC
;;;275    }
;;;276    void SerComSendMessageUser(const u8 * s){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;277    #ifdef USER_MSG_ENB
;;;278    	while(*s != 0)
000004  e00b              B        |L8.30|
                  |L8.6|
;;;279    	{
;;;280    		while (USART_GetFlagStatus(UART7, USART_FLAG_TC) == 0);
000006  bf00              NOP      
                  |L8.8|
000008  2140              MOVS     r1,#0x40
00000a  4807              LDR      r0,|L8.40|
00000c  f7fffffe          BL       USART_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0f9              BEQ      |L8.8|
;;;281    		USART_SendData(UART7,*s++);
000014  f8141b01          LDRB     r1,[r4],#1
000018  4803              LDR      r0,|L8.40|
00001a  f7fffffe          BL       USART_SendData
                  |L8.30|
00001e  7820              LDRB     r0,[r4,#0]            ;278
000020  2800              CMP      r0,#0                 ;278
000022  d1f0              BNE      |L8.6|
;;;282    	}
;;;283    #endif
;;;284    }
000024  bd10              POP      {r4,pc}
;;;285    
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x40007800

                          AREA ||i.SerComSendRsp||, CODE, READONLY, ALIGN=1

                  SerComSendRsp PROC
;;;106    
;;;107    void SerComSendRsp(u8 com,u8* d,u32 n)
000000  b570              PUSH     {r4-r6,lr}
;;;108    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;109    	u8 tmp[COM_MAX_SZ];
;;;110    	
;;;111    	tmp[0] = 0xFF;		//Header
00000a  20ff              MOVS     r0,#0xff
00000c  f88d0004          STRB     r0,[sp,#4]
;;;112    	tmp[1] = 0xFE;
000010  20fe              MOVS     r0,#0xfe
000012  f88d0005          STRB     r0,[sp,#5]
;;;113    	tmp[2] = com;
000016  f88d5006          STRB     r5,[sp,#6]
;;;114    	memcpy(&tmp[3],d,n); //payload
00001a  4622              MOV      r2,r4
00001c  4631              MOV      r1,r6
00001e  f10d0007          ADD      r0,sp,#7
000022  f7fffffe          BL       __aeabi_memcpy
;;;115    	tmp[n + 3] = 0xFF;	//Footer
000026  21ff              MOVS     r1,#0xff
000028  aa01              ADD      r2,sp,#4
00002a  1ce0              ADDS     r0,r4,#3
00002c  5411              STRB     r1,[r2,r0]
;;;116    	tmp[n + 4] = 0xFA;
00002e  21fa              MOVS     r1,#0xfa
000030  1d20              ADDS     r0,r4,#4
000032  5411              STRB     r1,[r2,r0]
;;;117    	SerComSendArr((void*)tmp,n+5);//send response
000034  1d61              ADDS     r1,r4,#5
000036  a801              ADD      r0,sp,#4
000038  f7fffffe          BL       SerComSendArr
;;;118    }
00003c  b006              ADD      sp,sp,#0x18
00003e  bd70              POP      {r4-r6,pc}
;;;119    
                          ENDP


                          AREA ||i.SerComSendStr||, CODE, READONLY, ALIGN=1

                  SerComSendStr PROC
;;;242    
;;;243    void SerComSendStr(u8* s){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;244    	while(*s != 0)
000004  e003              B        |L10.14|
                  |L10.6|
;;;245    		SerComSendByte(*s++);
000006  f8140b01          LDRB     r0,[r4],#1
00000a  f7fffffe          BL       SerComSendByte
                  |L10.14|
00000e  7820              LDRB     r0,[r4,#0]            ;244
000010  2800              CMP      r0,#0                 ;244
000012  d1f8              BNE      |L10.6|
;;;246    }
000014  bd10              POP      {r4,pc}
;;;247    
                          ENDP


                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;26     
;;;27     void USART2_IRQHandler(void)//Camera Com
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29     	//array is implemented as circular buffer for low latency operations
;;;30     	if( USART_GetITStatus(USART2, USART_IT_RXNE) ){
000002  f2405125          MOV      r1,#0x525
000006  4813              LDR      r0,|L11.84|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b300              CBZ      r0,|L11.80|
;;;31     
;;;32     		if(uRxFullFlg == 0)
00000e  4812              LDR      r0,|L11.88|
000010  7800              LDRB     r0,[r0,#0]  ; uRxFullFlg
000012  b958              CBNZ     r0,|L11.44|
;;;33     			uRxData[uRxWp++] = USART2->DR;//Store this byte
000014  490f              LDR      r1,|L11.84|
000016  1d09              ADDS     r1,r1,#4
000018  8809              LDRH     r1,[r1,#0]
00001a  b2ca              UXTB     r2,r1
00001c  490f              LDR      r1,|L11.92|
00001e  8808              LDRH     r0,[r1,#0]  ; uRxWp
000020  1c41              ADDS     r1,r0,#1
000022  4b0e              LDR      r3,|L11.92|
000024  8019              STRH     r1,[r3,#0]
000026  490e              LDR      r1,|L11.96|
000028  540a              STRB     r2,[r1,r0]
00002a  e002              B        |L11.50|
                  |L11.44|
;;;34     		else
;;;35     			USART2->DR;
00002c  4809              LDR      r0,|L11.84|
00002e  1d00              ADDS     r0,r0,#4
000030  8800              LDRH     r0,[r0,#0]
                  |L11.50|
;;;36     		
;;;37     		uRxWp &= (USART_RX_BUFFER_SZ-1);//Wrap around
000032  480a              LDR      r0,|L11.92|
000034  8800              LDRH     r0,[r0,#0]  ; uRxWp
000036  f000001f          AND      r0,r0,#0x1f
00003a  4908              LDR      r1,|L11.92|
00003c  8008              STRH     r0,[r1,#0]
;;;38     		
;;;39     		
;;;40     		if(uRxWp == uRxRp){
00003e  4608              MOV      r0,r1
000040  8800              LDRH     r0,[r0,#0]  ; uRxWp
000042  4908              LDR      r1,|L11.100|
000044  8809              LDRH     r1,[r1,#0]  ; uRxRp
000046  4288              CMP      r0,r1
000048  d102              BNE      |L11.80|
;;;41     			uRxFullFlg = 1;//Buffer is full				
00004a  2001              MOVS     r0,#1
00004c  4902              LDR      r1,|L11.88|
00004e  7008              STRB     r0,[r1,#0]
                  |L11.80|
;;;42     		}
;;;43     	}
;;;44     }
000050  bd10              POP      {r4,pc}
;;;45     u16 SerComCalculateUsedSpace(void)
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      0x40004400
                  |L11.88|
                          DCD      uRxFullFlg
                  |L11.92|
                          DCD      uRxWp
                  |L11.96|
                          DCD      uRxData
                  |L11.100|
                          DCD      uRxRp

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  uRxData
                          %        32
                  rxdata
                          %        20

                          AREA ||.data||, DATA, ALIGN=1

                  uRxRp
000000  0000              DCW      0x0000
                  uRxWp
000002  0000              DCW      0x0000
                  uRxFullFlg
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\serialcom.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_serialcom_c_uRxRp____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_serialcom_c_uRxRp____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_serialcom_c_uRxRp____REVSH|
#line 128
|__asm___11_serialcom_c_uRxRp____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
