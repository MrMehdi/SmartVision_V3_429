; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\out\camdrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\camdrv.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\ST\STM32F4xx\Include -I..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F4XX -DUSER_MSG_ENB -DWRITEIMAGEHEADER -DM16 -DSTM32F429_439xx --omf_browse=.\out\camdrv.crf ..\src\camdrv.c]
                          THUMB

                          AREA ||i.Cam_Configure_Peripherals||, CODE, READONLY, ALIGN=2

                  Cam_Configure_Peripherals PROC
;;;290    
;;;291    void Cam_Configure_Peripherals(void)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293    	Cam_IO_Configure();
000002  f7fffffe          BL       Cam_IO_Configure
;;;294    	Cam_DCMI_Config();
000006  f7fffffe          BL       Cam_DCMI_Config
;;;295    	Cam_DMA_Init();
00000a  f7fffffe          BL       Cam_DMA_Init
;;;296    	SLEEP_CAM12();
00000e  f44f6100          MOV      r1,#0x800
000012  4806              LDR      r0,|L1.44|
000014  f7fffffe          BL       GPIO_SetBits
000018  f44f5180          MOV      r1,#0x1000
00001c  4803              LDR      r0,|L1.44|
00001e  f7fffffe          BL       GPIO_SetBits
;;;297    	DIS_LDO();
000022  2120              MOVS     r1,#0x20
000024  4801              LDR      r0,|L1.44|
000026  f7fffffe          BL       GPIO_ResetBits
;;;298    }
00002a  bd10              POP      {r4,pc}
;;;299    
                          ENDP

                  |L1.44|
                          DCD      0x40020000

                          AREA ||i.Cam_DCMI_Config||, CODE, READONLY, ALIGN=2

                  Cam_DCMI_Config PROC
;;;182    
;;;183    void Cam_DCMI_Config(void)
000000  b500              PUSH     {lr}
;;;184    {
000002  b087              SUB      sp,sp,#0x1c
;;;185    	/*Vision
;;;186    
;;;187    HREF	PA4
;;;188    PCLK	PA6
;;;189    VSYN	PB7
;;;190    
;;;191    D0		PC6
;;;192    D1		PC7
;;;193    D2 		PC8
;;;194    D3		PC9
;;;195    D4		PC11c
;;;196    D5		PB6
;;;197    D6		PB8
;;;198    D7		PB9
;;;199    */  
;;;200    /*Vision*/
;;;201      DCMI_InitTypeDef DCMI_InitStructure;
;;;202      GPIO_InitTypeDef GPIO_InitStructure;
;;;203      NVIC_InitTypeDef NVIC_InitStructure;
;;;204    	
;;;205    	DCMI_DeInit();
000004  f7fffffe          BL       DCMI_DeInit
;;;206      /* Enable DCMI GPIOs clocks */
;;;207      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |  RCC_AHB1Periph_GPIOC |
000008  2101              MOVS     r1,#1
00000a  201f              MOVS     r0,#0x1f
00000c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;208                             RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE, ENABLE);
;;;209      /* Enable DCMI clock */
;;;210      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RCC_AHB2PeriphClockCmd
;;;211    
;;;212    
;;;213      GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_DCMI); //HSYNC
000018  220d              MOVS     r2,#0xd
00001a  2104              MOVS     r1,#4
00001c  484b              LDR      r0,|L2.332|
00001e  f7fffffe          BL       GPIO_PinAFConfig
;;;214      GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_DCMI); //PCLK
000022  220d              MOVS     r2,#0xd
000024  2106              MOVS     r1,#6
000026  4849              LDR      r0,|L2.332|
000028  f7fffffe          BL       GPIO_PinAFConfig
;;;215      GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_DCMI); //VSYNC
00002c  220d              MOVS     r2,#0xd
00002e  2107              MOVS     r1,#7
000030  4847              LDR      r0,|L2.336|
000032  f7fffffe          BL       GPIO_PinAFConfig
;;;216    	
;;;217      GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_DCMI); //DCMI0
000036  220d              MOVS     r2,#0xd
000038  2106              MOVS     r1,#6
00003a  4846              LDR      r0,|L2.340|
00003c  f7fffffe          BL       GPIO_PinAFConfig
;;;218      GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_DCMI); //DCMI1
000040  220d              MOVS     r2,#0xd
000042  2107              MOVS     r1,#7
000044  4843              LDR      r0,|L2.340|
000046  f7fffffe          BL       GPIO_PinAFConfig
;;;219    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_DCMI); //DCMI2
00004a  220d              MOVS     r2,#0xd
00004c  2108              MOVS     r1,#8
00004e  4841              LDR      r0,|L2.340|
000050  f7fffffe          BL       GPIO_PinAFConfig
;;;220      GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_DCMI); //DCMI3
000054  220d              MOVS     r2,#0xd
000056  2109              MOVS     r1,#9
000058  483e              LDR      r0,|L2.340|
00005a  f7fffffe          BL       GPIO_PinAFConfig
;;;221      GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_DCMI);//DCMI4
00005e  220d              MOVS     r2,#0xd
000060  210b              MOVS     r1,#0xb
000062  483c              LDR      r0,|L2.340|
000064  f7fffffe          BL       GPIO_PinAFConfig
;;;222      GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_DCMI); //DCMI5
000068  220d              MOVS     r2,#0xd
00006a  2106              MOVS     r1,#6
00006c  4838              LDR      r0,|L2.336|
00006e  f7fffffe          BL       GPIO_PinAFConfig
;;;223      GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_DCMI); //DCMI6
000072  220d              MOVS     r2,#0xd
000074  2108              MOVS     r1,#8
000076  4836              LDR      r0,|L2.336|
000078  f7fffffe          BL       GPIO_PinAFConfig
;;;224      GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_DCMI); //DCMI7
00007c  220d              MOVS     r2,#0xd
00007e  2109              MOVS     r1,#9
000080  4833              LDR      r0,|L2.336|
000082  f7fffffe          BL       GPIO_PinAFConfig
;;;225    
;;;226      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000086  2002              MOVS     r0,#2
000088  f88d0008          STRB     r0,[sp,#8]
;;;227      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00008c  2003              MOVS     r0,#3
00008e  f88d0009          STRB     r0,[sp,#9]
;;;228      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000092  2000              MOVS     r0,#0
000094  f88d000a          STRB     r0,[sp,#0xa]
;;;229      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
000098  2001              MOVS     r0,#1
00009a  f88d000b          STRB     r0,[sp,#0xb]
;;;230    
;;;231      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_11;  //D0 - D4
00009e  f44f603c          MOV      r0,#0xbc0
0000a2  9001              STR      r0,[sp,#4]
;;;232      GPIO_Init(GPIOC, &GPIO_InitStructure);
0000a4  a901              ADD      r1,sp,#4
0000a6  482b              LDR      r0,|L2.340|
0000a8  f7fffffe          BL       GPIO_Init
;;;233    	
;;;234    
;;;235    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7| GPIO_Pin_8 | GPIO_Pin_9;  //D5 - D7, VSYNC
0000ac  f44f7070          MOV      r0,#0x3c0
0000b0  9001              STR      r0,[sp,#4]
;;;236      GPIO_Init(GPIOB, &GPIO_InitStructure);
0000b2  a901              ADD      r1,sp,#4
0000b4  4826              LDR      r0,|L2.336|
0000b6  f7fffffe          BL       GPIO_Init
;;;237    	
;;;238    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  
0000ba  f44f7000          MOV      r0,#0x200
0000be  9001              STR      r0,[sp,#4]
;;;239      GPIO_Init(GPIOB, &GPIO_InitStructure);
0000c0  a901              ADD      r1,sp,#4
0000c2  4823              LDR      r0,|L2.336|
0000c4  f7fffffe          BL       GPIO_Init
;;;240    	
;;;241    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;  //HSYNC
0000c8  2010              MOVS     r0,#0x10
0000ca  9001              STR      r0,[sp,#4]
;;;242      GPIO_Init(GPIOA, &GPIO_InitStructure);	
0000cc  a901              ADD      r1,sp,#4
0000ce  481f              LDR      r0,|L2.332|
0000d0  f7fffffe          BL       GPIO_Init
;;;243    
;;;244      // PCLK(PA6)
;;;245      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
0000d4  2040              MOVS     r0,#0x40
0000d6  9001              STR      r0,[sp,#4]
;;;246      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000d8  2002              MOVS     r0,#2
0000da  f88d0008          STRB     r0,[sp,#8]
;;;247      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000de  2000              MOVS     r0,#0
0000e0  f88d000a          STRB     r0,[sp,#0xa]
;;;248      GPIO_Init(GPIOA, &GPIO_InitStructure);
0000e4  a901              ADD      r1,sp,#4
0000e6  4819              LDR      r0,|L2.332|
0000e8  f7fffffe          BL       GPIO_Init
;;;249    		
;;;250      /* DCMI configuration *******************************************************/ 
;;;251      DCMI_InitStructure.DCMI_CaptureMode = DCMI_CaptureMode_SnapShot;
0000ec  2002              MOVS     r0,#2
0000ee  f8ad000c          STRH     r0,[sp,#0xc]
;;;252      DCMI_InitStructure.DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
0000f2  2000              MOVS     r0,#0
0000f4  f8ad000e          STRH     r0,[sp,#0xe]
;;;253      DCMI_InitStructure.DCMI_PCKPolarity = DCMI_PCKPolarity_Rising;
0000f8  2020              MOVS     r0,#0x20
0000fa  f8ad0010          STRH     r0,[sp,#0x10]
;;;254      DCMI_InitStructure.DCMI_VSPolarity = DCMI_VSPolarity_Low; //DCMI_VSPolarity_High
0000fe  2000              MOVS     r0,#0
000100  f8ad0012          STRH     r0,[sp,#0x12]
;;;255      DCMI_InitStructure.DCMI_HSPolarity = DCMI_HSPolarity_Low; //DCMI_HSPolarity_High
000104  f8ad0014          STRH     r0,[sp,#0x14]
;;;256      DCMI_InitStructure.DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;//DCMI_CaptureRate_All_Frame
000108  f8ad0016          STRH     r0,[sp,#0x16]
;;;257      DCMI_InitStructure.DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b; //?
00010c  f8ad0018          STRH     r0,[sp,#0x18]
;;;258      
;;;259      DCMI_Init(&DCMI_InitStructure);
000110  a803              ADD      r0,sp,#0xc
000112  f7fffffe          BL       DCMI_Init
;;;260    
;;;261    	DCMI_JPEGCmd(ENABLE);
000116  2001              MOVS     r0,#1
000118  f7fffffe          BL       DCMI_JPEGCmd
;;;262          
;;;263      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
00011c  f44f60e0          MOV      r0,#0x700
000120  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;264      NVIC_InitStructure.NVIC_IRQChannel = DCMI_IRQn;
000124  204e              MOVS     r0,#0x4e
000126  f88d0000          STRB     r0,[sp,#0]
;;;265      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00012a  2000              MOVS     r0,#0
00012c  f88d0001          STRB     r0,[sp,#1]
;;;266      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000130  2001              MOVS     r0,#1
000132  f88d0002          STRB     r0,[sp,#2]
;;;267      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  
000136  f88d0003          STRB     r0,[sp,#3]
;;;268    	NVIC_Init(&NVIC_InitStructure); 
00013a  4668              MOV      r0,sp
00013c  f7fffffe          BL       NVIC_Init
;;;269    
;;;270      DCMI_ITConfig(DCMI_IT_FRAME, ENABLE);
000140  2101              MOVS     r1,#1
000142  4608              MOV      r0,r1
000144  f7fffffe          BL       DCMI_ITConfig
;;;271    
;;;272    }
000148  b007              ADD      sp,sp,#0x1c
00014a  bd00              POP      {pc}
;;;273    
                          ENDP

                  |L2.332|
                          DCD      0x40020000
                  |L2.336|
                          DCD      0x40020400
                  |L2.340|
                          DCD      0x40020800

                          AREA ||i.Cam_DMA_Init||, CODE, READONLY, ALIGN=2

                  Cam_DMA_Init PROC
;;;139    
;;;140    void Cam_DMA_Init(void)
000000  b500              PUSH     {lr}
;;;141    {
000002  b091              SUB      sp,sp,#0x44
;;;142      DMA_InitTypeDef  DMA_InitStructure;
;;;143      NVIC_InitTypeDef NVIC_InitStructure;
;;;144    	
;;;145    	/* Configures the DMA2 to transfer Data from DCMI to the LCD ****************/
;;;146      /* Enable DMA2 clock */
;;;147    	
;;;148      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);   
000004  2101              MOVS     r1,#1
000006  0588              LSLS     r0,r1,#22
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;149      /* DMA2 Stream1 Configuration */  
;;;150      DMA_DeInit(DMA2_Stream1);
00000c  481f              LDR      r0,|L3.140|
00000e  f7fffffe          BL       DMA_DeInit
;;;151    
;;;152      DMA_InitStructure.DMA_Channel = DMA_Channel_1;  
000012  f04f7000          MOV      r0,#0x2000000
000016  9002              STR      r0,[sp,#8]
;;;153      DMA_InitStructure.DMA_PeripheralBaseAddr = DCMI_DR_ADDRESS;	
000018  481d              LDR      r0,|L3.144|
00001a  9003              STR      r0,[sp,#0xc]
;;;154      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)JpegBuffer;	
00001c  481d              LDR      r0,|L3.148|
00001e  9004              STR      r0,[sp,#0x10]
;;;155      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
000020  2000              MOVS     r0,#0
000022  9005              STR      r0,[sp,#0x14]
;;;156      DMA_InitStructure.DMA_BufferSize = 0xFFFF;  
000024  f64f70ff          MOV      r0,#0xffff
000028  9006              STR      r0,[sp,#0x18]
;;;157    	//DMA_InitStructure.DMA_BufferSize = 1;  
;;;158      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00002a  2000              MOVS     r0,#0
00002c  9007              STR      r0,[sp,#0x1c]
;;;159      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00002e  f44f6080          MOV      r0,#0x400
000032  9008              STR      r0,[sp,#0x20]
;;;160      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
000034  0080              LSLS     r0,r0,#2
000036  9009              STR      r0,[sp,#0x24]
;;;161      //DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
;;;162    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000038  0040              LSLS     r0,r0,#1
00003a  900a              STR      r0,[sp,#0x28]
;;;163      //DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
;;;164    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
00003c  2000              MOVS     r0,#0
00003e  900b              STR      r0,[sp,#0x2c]
;;;165      DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
000040  f44f3040          MOV      r0,#0x30000
000044  900c              STR      r0,[sp,#0x30]
;;;166    	//DMA_InitStructure.DMA_Priority =DMA_Priority_High;
;;;167      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;        
000046  2004              MOVS     r0,#4
000048  900d              STR      r0,[sp,#0x34]
;;;168      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
00004a  2003              MOVS     r0,#3
00004c  900e              STR      r0,[sp,#0x38]
;;;169      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
00004e  2000              MOVS     r0,#0
000050  900f              STR      r0,[sp,#0x3c]
;;;170    	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_INC4;
000052  f44f0000          MOV      r0,#0x800000
000056  900f              STR      r0,[sp,#0x3c]
;;;171      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
000058  2000              MOVS     r0,#0
00005a  9010              STR      r0,[sp,#0x40]
;;;172      DMA_Init(DMA2_Stream1, &DMA_InitStructure); 
00005c  a902              ADD      r1,sp,#8
00005e  480b              LDR      r0,|L3.140|
000060  f7fffffe          BL       DMA_Init
;;;173    		
;;;174      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000064  f44f60e0          MOV      r0,#0x700
000068  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;175      NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream1_IRQn;                    
00006c  2039              MOVS     r0,#0x39
00006e  f88d0004          STRB     r0,[sp,#4]
;;;176      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000072  2000              MOVS     r0,#0
000074  f88d0005          STRB     r0,[sp,#5]
;;;177      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000078  f88d0006          STRB     r0,[sp,#6]
;;;178      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00007c  2001              MOVS     r0,#1
00007e  f88d0007          STRB     r0,[sp,#7]
;;;179      NVIC_Init(&NVIC_InitStructure);
000082  a801              ADD      r0,sp,#4
000084  f7fffffe          BL       NVIC_Init
;;;180    	
;;;181    }
000088  b011              ADD      sp,sp,#0x44
00008a  bd00              POP      {pc}
;;;182    
                          ENDP

                  |L3.140|
                          DCD      0x40026428
                  |L3.144|
                          DCD      0x50050028
                  |L3.148|
                          DCD      JpegBuffer

                          AREA ||i.Cam_Get_Image||, CODE, READONLY, ALIGN=2

                  Cam_Get_Image PROC
;;;317    
;;;318    u8 Cam_Get_Image(void)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320    
;;;321    	DCMI_Cmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       DCMI_Cmd
;;;322    	DMA_Cmd(DMA2_Stream1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4814              LDR      r0,|L4.92|
00000c  f7fffffe          BL       DMA_Cmd
;;;323    	DCMI_CaptureCmd(ENABLE);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       DCMI_CaptureCmd
;;;324    	
;;;325    	jpegCaptureDoneITFLG = 0;
000016  2000              MOVS     r0,#0
000018  4911              LDR      r1,|L4.96|
00001a  7008              STRB     r0,[r1,#0]
;;;326    	jpegCaptureTime	= 0;
00001c  4911              LDR      r1,|L4.100|
00001e  6008              STR      r0,[r1,#0]  ; jpegCaptureTime
;;;327    	
;;;328    	while(jpegCaptureDoneITFLG ==0)
000020  e00f              B        |L4.66|
                  |L4.34|
;;;329    	{
;;;330    		if(jpegCaptureTime > CAMERA_IMGCAPTURE_TIMEOUT)
000022  4810              LDR      r0,|L4.100|
000024  6800              LDR      r0,[r0,#0]  ; jpegCaptureTime
000026  f5b06ffa          CMP      r0,#0x7d0
00002a  d90a              BLS      |L4.66|
;;;331    		{
;;;332    			jpegTotalTime += CAMERA_IMGCAPTURE_TIMEOUT;//Camera image capture failed
00002c  480e              LDR      r0,|L4.104|
00002e  6800              LDR      r0,[r0,#0]  ; jpegTotalTime
000030  f50060fa          ADD      r0,r0,#0x7d0
000034  490c              LDR      r1,|L4.104|
000036  6008              STR      r0,[r1,#0]  ; jpegTotalTime
;;;333    			SerComSendMessageUser("Camera Capture Timed out\r\n");
000038  a00c              ADR      r0,|L4.108|
00003a  f7fffffe          BL       SerComSendMessageUser
;;;334    			return 0;
00003e  2000              MOVS     r0,#0
                  |L4.64|
;;;335    		}
;;;336    	}
;;;337    	jpegTotalTime += jpegCaptureTime;	//store total capture time
;;;338    	
;;;339    	return 1;
;;;340    		
;;;341    }
000040  bd10              POP      {r4,pc}
                  |L4.66|
000042  4807              LDR      r0,|L4.96|
000044  7800              LDRB     r0,[r0,#0]            ;328  ; jpegCaptureDoneITFLG
000046  2800              CMP      r0,#0                 ;328
000048  d0eb              BEQ      |L4.34|
00004a  4807              LDR      r0,|L4.104|
00004c  6800              LDR      r0,[r0,#0]            ;337  ; jpegTotalTime
00004e  4905              LDR      r1,|L4.100|
000050  6809              LDR      r1,[r1,#0]            ;337  ; jpegCaptureTime
000052  4408              ADD      r0,r0,r1              ;337
000054  4904              LDR      r1,|L4.104|
000056  6008              STR      r0,[r1,#0]            ;337  ; jpegTotalTime
000058  2001              MOVS     r0,#1                 ;339
00005a  e7f1              B        |L4.64|
;;;342    
                          ENDP

                  |L4.92|
                          DCD      0x40026428
                  |L4.96|
                          DCD      jpegCaptureDoneITFLG
                  |L4.100|
                          DCD      jpegCaptureTime
                  |L4.104|
                          DCD      jpegTotalTime
                  |L4.108|
00006c  43616d65          DCB      "Camera Capture Timed out\r\n",0
000070  72612043
000074  61707475
000078  72652054
00007c  696d6564
000080  206f7574
000084  0d0a00  
000087  00                DCB      0

                          AREA ||i.Cam_IO_Configure||, CODE, READONLY, ALIGN=2

                  Cam_IO_Configure PROC
;;;273    
;;;274    void Cam_IO_Configure(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;275    {
;;;276    
;;;277    	GPIO_InitTypeDef GPIO_InitStruct;
;;;278    	
;;;279    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;280    	GPIO_InitStruct.GPIO_Mode  = GPIO_Mode_OUT;
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;281    	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;282    	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
000016  2003              MOVS     r0,#3
000018  f88d0005          STRB     r0,[sp,#5]
;;;283    	GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_UP;
00001c  2001              MOVS     r0,#1
00001e  f88d0007          STRB     r0,[sp,#7]
;;;284    	GPIO_InitStruct.GPIO_Pin   = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_5 |  GPIO_Pin_9;
000022  f44f50d1          MOV      r0,#0x1a20
000026  9000              STR      r0,[sp,#0]
;;;285    	GPIO_Init(GPIOA, &GPIO_InitStruct);
000028  4669              MOV      r1,sp
00002a  4802              LDR      r0,|L5.52|
00002c  f7fffffe          BL       GPIO_Init
;;;286    
;;;287    }
000030  bd1c              POP      {r2-r4,pc}
;;;288    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40020000

                          AREA ||i.Cam_Init_Power||, CODE, READONLY, ALIGN=2

                  Cam_Init_Power PROC
;;;300    
;;;301    u8 Cam_Init_Power(void)
000000  b510              PUSH     {r4,lr}
;;;302    {	
;;;303    	u8 err=0;
000002  2400              MOVS     r4,#0
;;;304    	SCCBSetAdress(OV2640_DEVICE_WRITE_ADDRESS);//required by api
000004  2060              MOVS     r0,#0x60
000006  f7fffffe          BL       SCCBSetAdress
;;;305    	enable_clock();
00000a  f7fffffe          BL       enable_clock
;;;306    	Delayms(1);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       Delayms
;;;307    	ENB_LDO();
000014  2120              MOVS     r1,#0x20
000016  4812              LDR      r0,|L6.96|
000018  f7fffffe          BL       GPIO_SetBits
;;;308    	Delayms(10);
00001c  200a              MOVS     r0,#0xa
00001e  f7fffffe          BL       Delayms
;;;309    	SerComSendMessageUser("Hard-reset Cameras\r\n");
000022  a010              ADR      r0,|L6.100|
000024  f7fffffe          BL       SerComSendMessageUser
;;;310    	ENB_RST();
000028  f44f7100          MOV      r1,#0x200
00002c  480c              LDR      r0,|L6.96|
00002e  f7fffffe          BL       GPIO_ResetBits
;;;311    	Delayms(50);
000032  2032              MOVS     r0,#0x32
000034  f7fffffe          BL       Delayms
;;;312    	DIS_RST();           
000038  f44f7100          MOV      r1,#0x200
00003c  4808              LDR      r0,|L6.96|
00003e  f7fffffe          BL       GPIO_SetBits
;;;313    	Delayms(50);
000042  2032              MOVS     r0,#0x32
000044  f7fffffe          BL       Delayms
;;;314      SLEEP_CAM12();
000048  f44f6100          MOV      r1,#0x800
00004c  4804              LDR      r0,|L6.96|
00004e  f7fffffe          BL       GPIO_SetBits
000052  f44f5180          MOV      r1,#0x1000
000056  4802              LDR      r0,|L6.96|
000058  f7fffffe          BL       GPIO_SetBits
;;;315    	return err;
00005c  4620              MOV      r0,r4
;;;316    }
00005e  bd10              POP      {r4,pc}
;;;317    
                          ENDP

                  |L6.96|
                          DCD      0x40020000
                  |L6.100|
000064  48617264          DCB      "Hard-reset Cameras\r\n",0
000068  2d726573
00006c  65742043
000070  616d6572
000074  61730d0a
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.Cam_LED||, CODE, READONLY, ALIGN=2

                  Cam_LED PROC
;;;79     
;;;80     void Cam_LED(unsigned char st)
000000  b510              PUSH     {r4,lr}
;;;81     {
000002  4604              MOV      r4,r0
;;;82     	GPIO_WriteBit(CAM_LED_PORT, CAM_LED_PIN,st);
000004  4622              MOV      r2,r4
000006  2104              MOVS     r1,#4
000008  4801              LDR      r0,|L7.16|
00000a  f7fffffe          BL       GPIO_WriteBit
;;;83     }
00000e  bd10              POP      {r4,pc}
;;;84     void Cam_Reset(unsigned char st)
                          ENDP

                  |L7.16|
                          DCD      0x40020400

                          AREA ||i.Cam_Power_Down||, CODE, READONLY, ALIGN=2

                  Cam_Power_Down PROC
;;;88     
;;;89     void Cam_Power_Down(unsigned char cam,unsigned char st)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;91     	if(cam == CAM1)
000006  2c01              CMP      r4,#1
000008  d104              BNE      |L8.20|
;;;92     	{
;;;93     		GPIO_WriteBit(CAM_PWD1_PORT, CAM_PWD1_PIN, st);
00000a  462a              MOV      r2,r5
00000c  02c1              LSLS     r1,r0,#11
00000e  4806              LDR      r0,|L8.40|
000010  f7fffffe          BL       GPIO_WriteBit
                  |L8.20|
;;;94     	}
;;;95     	if(cam == CAM2)
000014  2c02              CMP      r4,#2
000016  d105              BNE      |L8.36|
;;;96     	{
;;;97     		GPIO_WriteBit(CAM_PWD2_PORT, CAM_PWD2_PIN, st);
000018  462a              MOV      r2,r5
00001a  02e1              LSLS     r1,r4,#11
00001c  4802              LDR      r0,|L8.40|
00001e  f7fffffe          BL       GPIO_WriteBit
000022  e000              B        |L8.38|
                  |L8.36|
;;;98     	}
;;;99     	else
;;;100    	{
;;;101    		assert_param(0);//invalid parameter passed
000024  bf00              NOP      
                  |L8.38|
;;;102    	}
;;;103    }
000026  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP

                  |L8.40|
                          DCD      0x40020000

                          AREA ||i.Cam_Reset||, CODE, READONLY, ALIGN=2

                  Cam_Reset PROC
;;;83     }
;;;84     void Cam_Reset(unsigned char st)
000000  b510              PUSH     {r4,lr}
;;;85     {
000002  4604              MOV      r4,r0
;;;86     	GPIO_WriteBit(CAM_RST_PORT, CAM_RST_PIN,st);
000004  4622              MOV      r2,r4
000006  2103              MOVS     r1,#3
000008  4801              LDR      r0,|L9.16|
00000a  f7fffffe          BL       GPIO_WriteBit
;;;87     }
00000e  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L9.16|
                          DCD      0x40020400

                          AREA ||i.Cam_click_images||, CODE, READONLY, ALIGN=2

                  Cam_click_images PROC
;;;342    
;;;343    u8 Cam_click_images(u16 dly,u32 * nseq,u32 * fsz)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;344    {
000004  4682              MOV      r10,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;345    	u8 err=0;
00000a  2500              MOVS     r5,#0
;;;346    	u8 sb[50];
;;;347    	u8 handle;
;;;348    	u32 seq;
;;;349    	u32 sz[2],i,k = 0;
00000c  46a8              MOV      r8,r5
;;;350    	jpegTotalTime = 0;
00000e  2000              MOVS     r0,#0
000010  4977              LDR      r1,|L10.496|
000012  6008              STR      r0,[r1,#0]  ; jpegTotalTime
;;;351    	sz[0] = sz[1] = 0;
000014  9001              STR      r0,[sp,#4]
000016  9000              STR      r0,[sp,#0]
;;;352    	
;;;353    	
;;;354    	ENB_CAM1_ACCESS();
000018  f44f6100          MOV      r1,#0x800
00001c  4875              LDR      r0,|L10.500|
00001e  f7fffffe          BL       GPIO_ResetBits
000022  f44f5180          MOV      r1,#0x1000
000026  4873              LDR      r0,|L10.500|
000028  f7fffffe          BL       GPIO_SetBits
;;;355    	CamApi_Init_Regs();
00002c  f7fffffe          BL       CamApi_Init_Regs
;;;356    
;;;357    	
;;;358    	if(Cam_Get_Image()==0)//capture image on DCMI
000030  f7fffffe          BL       Cam_Get_Image
000034  b908              CBNZ     r0,|L10.58|
;;;359    		err |= ERROR_HARD_CAM1;
000036  f0450503          ORR      r5,r5,#3
                  |L10.58|
;;;360    	
;;;361    	ENB_CAM2_ACCESS();
00003a  f44f5180          MOV      r1,#0x1000
00003e  486d              LDR      r0,|L10.500|
000040  f7fffffe          BL       GPIO_ResetBits
000044  f44f6100          MOV      r1,#0x800
000048  486a              LDR      r0,|L10.500|
00004a  f7fffffe          BL       GPIO_SetBits
;;;362    	CamApi_Init_Regs();
00004e  f7fffffe          BL       CamApi_Init_Regs
;;;363    	
;;;364      //move image to buffer and calculate image size
;;;365      if(JpegBuffer[0] == 0xFF && JpegBuffer[1] == 0xD8)
000052  4869              LDR      r0,|L10.504|
000054  7800              LDRB     r0,[r0,#0]  ; JpegBuffer
000056  28ff              CMP      r0,#0xff
000058  d126              BNE      |L10.168|
00005a  4867              LDR      r0,|L10.504|
00005c  7840              LDRB     r0,[r0,#1]  ; JpegBuffer
00005e  28d8              CMP      r0,#0xd8
000060  d122              BNE      |L10.168|
;;;366    	{
;;;367    		i=0;
000062  2400              MOVS     r4,#0
;;;368    		while(i < JPEG_BUFFER_SZ)
000064  e01c              B        |L10.160|
                  |L10.102|
;;;369    		{		
;;;370    		
;;;371    			if(i < OFFLOAD_BUFFER_1SZ)
000066  f5b44f60          CMP      r4,#0xe000
00006a  d204              BCS      |L10.118|
;;;372    			{
;;;373    				Jpeg_b1[i] = JpegBuffer[i];//store in offload buffer 1
00006c  4862              LDR      r0,|L10.504|
00006e  5d00              LDRB     r0,[r0,r4]
000070  4962              LDR      r1,|L10.508|
000072  5508              STRB     r0,[r1,r4]
000074  e005              B        |L10.130|
                  |L10.118|
;;;374    			}
;;;375    			else
;;;376    			{
;;;377    				Jpeg_b2[ i - OFFLOAD_BUFFER_1SZ] = JpegBuffer[i];//store in offload buffer 2
000076  4860              LDR      r0,|L10.504|
000078  5d01              LDRB     r1,[r0,r4]
00007a  f5a44060          SUB      r0,r4,#0xe000
00007e  4a60              LDR      r2,|L10.512|
000080  5411              STRB     r1,[r2,r0]
                  |L10.130|
;;;378    			}
;;;379    			if(i > 2 )
000082  2c02              CMP      r4,#2
000084  d90b              BLS      |L10.158|
;;;380    			{
;;;381    				if(JpegBuffer[i] == 0xD9 && JpegBuffer[i-1] == 0xFF)
000086  485c              LDR      r0,|L10.504|
000088  5d00              LDRB     r0,[r0,r4]
00008a  28d9              CMP      r0,#0xd9
00008c  d107              BNE      |L10.158|
00008e  1e60              SUBS     r0,r4,#1
000090  4959              LDR      r1,|L10.504|
000092  5c08              LDRB     r0,[r1,r0]
000094  28ff              CMP      r0,#0xff
000096  d102              BNE      |L10.158|
;;;382    				{
;;;383    					sz[0] = i+1;//store size of this image
000098  1c60              ADDS     r0,r4,#1
00009a  9000              STR      r0,[sp,#0]
;;;384    					break;
00009c  e003              B        |L10.166|
                  |L10.158|
;;;385    				}	
;;;386    			}
;;;387    			i++;
00009e  1c64              ADDS     r4,r4,#1
                  |L10.160|
0000a0  f5b43ff0          CMP      r4,#0x1e000           ;368
0000a4  d3df              BCC      |L10.102|
                  |L10.166|
0000a6  bf00              NOP                            ;384
                  |L10.168|
;;;388    		}
;;;389    	}
;;;390    	
;;;391    	JpegBuffer[0] = 0;//clear jpeg header
0000a8  2000              MOVS     r0,#0
0000aa  4953              LDR      r1,|L10.504|
0000ac  7008              STRB     r0,[r1,#0]
;;;392    	
;;;393    	DCMI_Cmd(DISABLE);//Prepare for next image capture
0000ae  f7fffffe          BL       DCMI_Cmd
;;;394    	DCMI_CaptureCmd(DISABLE);
0000b2  2000              MOVS     r0,#0
0000b4  f7fffffe          BL       DCMI_CaptureCmd
;;;395    	Cam_DCMI_Config();
0000b8  f7fffffe          BL       Cam_DCMI_Config
;;;396    	Cam_DMA_Init();
0000bc  f7fffffe          BL       Cam_DMA_Init
;;;397    	
;;;398    	//Reset DMA if required
;;;399    	if(Cam_Get_Image()==0)					//capture image on DCMI
0000c0  f7fffffe          BL       Cam_Get_Image
0000c4  b908              CBNZ     r0,|L10.202|
;;;400    		err |= ERROR_HARD_CAM2;
0000c6  f0450504          ORR      r5,r5,#4
                  |L10.202|
;;;401    	 
;;;402    	
;;;403    	SLEEP_CAM12();
0000ca  f44f6100          MOV      r1,#0x800
0000ce  4849              LDR      r0,|L10.500|
0000d0  f7fffffe          BL       GPIO_SetBits
0000d4  f44f5180          MOV      r1,#0x1000
0000d8  4846              LDR      r0,|L10.500|
0000da  f7fffffe          BL       GPIO_SetBits
;;;404    	
;;;405    	DMA_Cmd(DMA2_Stream1, DISABLE);	
0000de  2100              MOVS     r1,#0
0000e0  4848              LDR      r0,|L10.516|
0000e2  f7fffffe          BL       DMA_Cmd
;;;406    	DCMI_Cmd(DISABLE);
0000e6  2000              MOVS     r0,#0
0000e8  f7fffffe          BL       DCMI_Cmd
;;;407    	DCMI_CaptureCmd(DISABLE);
0000ec  2000              MOVS     r0,#0
0000ee  f7fffffe          BL       DCMI_CaptureCmd
;;;408    	Cam_DCMI_Config();
0000f2  f7fffffe          BL       Cam_DCMI_Config
;;;409    	Cam_DMA_Init();
0000f6  f7fffffe          BL       Cam_DMA_Init
;;;410    	
;;;411    	//Get size of second image
;;;412    	if(JpegBuffer[0] == 0xFF && JpegBuffer[1] == 0xD8)
0000fa  483f              LDR      r0,|L10.504|
0000fc  7800              LDRB     r0,[r0,#0]  ; JpegBuffer
0000fe  28ff              CMP      r0,#0xff
000100  d116              BNE      |L10.304|
000102  483d              LDR      r0,|L10.504|
000104  7840              LDRB     r0,[r0,#1]  ; JpegBuffer
000106  28d8              CMP      r0,#0xd8
000108  d112              BNE      |L10.304|
;;;413    	{
;;;414    		for(i=0;i<JPEG_BUFFER_SZ;i++)
00010a  2400              MOVS     r4,#0
00010c  e00c              B        |L10.296|
                  |L10.270|
;;;415    		{
;;;416    			if(JpegBuffer[i] == 0xFF && JpegBuffer[i+1] == 0xD9)
00010e  483a              LDR      r0,|L10.504|
000110  5d00              LDRB     r0,[r0,r4]
000112  28ff              CMP      r0,#0xff
000114  d107              BNE      |L10.294|
000116  4938              LDR      r1,|L10.504|
000118  1c60              ADDS     r0,r4,#1
00011a  5c08              LDRB     r0,[r1,r0]
00011c  28d9              CMP      r0,#0xd9
00011e  d102              BNE      |L10.294|
;;;417    			{
;;;418    				sz[1] = i+2;
000120  1ca0              ADDS     r0,r4,#2
000122  9001              STR      r0,[sp,#4]
;;;419    				break;
000124  e003              B        |L10.302|
                  |L10.294|
000126  1c64              ADDS     r4,r4,#1              ;414
                  |L10.296|
000128  f5b43ff0          CMP      r4,#0x1e000           ;414
00012c  d3ef              BCC      |L10.270|
                  |L10.302|
00012e  bf00              NOP      
                  |L10.304|
;;;420    			}
;;;421    		}
;;;422    	}
;;;423    
;;;424    	if(sz[0] > 0 || sz [1] > 0 )
000130  9800              LDR      r0,[sp,#0]
000132  b910              CBNZ     r0,|L10.314|
000134  9801              LDR      r0,[sp,#4]
000136  2800              CMP      r0,#0
000138  d053              BEQ      |L10.482|
                  |L10.314|
;;;425    	{	
;;;426    		//Get a File Access		
;;;427    		handle = FlashCreateNewFile(&seq);
00013a  a802              ADD      r0,sp,#8
00013c  f7fffffe          BL       FlashCreateNewFile
000140  4681              MOV      r9,r0
;;;428    		i = 0;//This is the variabe to count bytes written
000142  2400              MOVS     r4,#0
;;;429    		
;;;430    		//Write debug imformation header , settings poplated on bootup
;;;431    		imgdebug.header= 0XABCDEF01;
000144  4830              LDR      r0,|L10.520|
000146  4931              LDR      r1,|L10.524|
000148  6008              STR      r0,[r1,#0]  ; imgdebug
;;;432    		imgdebug.captime = jpegTotalTime;
00014a  4829              LDR      r0,|L10.496|
00014c  6800              LDR      r0,[r0,#0]  ; jpegTotalTime
00014e  6148              STR      r0,[r1,#0x14]  ; imgdebug
;;;433    		imgdebug.error = err;
000150  4608              MOV      r0,r1
000152  60c5              STR      r5,[r0,#0xc]  ; imgdebug
;;;434    		imgdebug.filesz[0]=sz[1];
000154  9801              LDR      r0,[sp,#4]
000156  6048              STR      r0,[r1,#4]  ; imgdebug
;;;435    		imgdebug.filesz[1]=sz[0];
000158  482c              LDR      r0,|L10.524|
00015a  9900              LDR      r1,[sp,#0]
00015c  6081              STR      r1,[r0,#8]
;;;436    		imgdebug.seqno=seq;
00015e  492b              LDR      r1,|L10.524|
000160  9802              LDR      r0,[sp,#8]
000162  6108              STR      r0,[r1,#0x10]  ; imgdebug
;;;437    		imgdebug.footer = 0xFFFE;
000164  f64f70fe          MOV      r0,#0xfffe
000168  f8a10044          STRH     r0,[r1,#0x44]
;;;438    		
;;;439    	  FlashFileWrite(i,handle,(void*)&imgdebug.header,sizeof(imgdebug));
00016c  2348              MOVS     r3,#0x48
00016e  460a              MOV      r2,r1
000170  4649              MOV      r1,r9
000172  4620              MOV      r0,r4
000174  f7fffffe          BL       FlashFileWrite
;;;440    		i = 512;//Leaving a 512 byte space to reduce RAM . TODO optimize this
000178  f44f7400          MOV      r4,#0x200
;;;441    		
;;;442    
;;;443    		if(sz[0] > 0 )//write Second file
00017c  9800              LDR      r0,[sp,#0]
00017e  b130              CBZ      r0,|L10.398|
;;;444    		{
;;;445    			i += FlashFileWrite(i,handle,JpegBuffer,sz[1]);
000180  4a1d              LDR      r2,|L10.504|
000182  4649              MOV      r1,r9
000184  4620              MOV      r0,r4
000186  9b01              LDR      r3,[sp,#4]
000188  f7fffffe          BL       FlashFileWrite
00018c  4404              ADD      r4,r4,r0
                  |L10.398|
;;;446    #ifdef UART_IMG_DUMP
;;;447    		SerComSendArrayUser(JpegBuffer,sz[1]);
;;;448    #endif	
;;;449    		}
;;;450    
;;;451    		if(sz[0] > 0 )//write First file
00018e  9800              LDR      r0,[sp,#0]
000190  b308              CBZ      r0,|L10.470|
;;;452    		{
;;;453    			k = i%512; //Continue writing at 512 byte boundary
000192  f3c40808          UBFX     r8,r4,#0,#9
;;;454    			i += 512-k; //TODO optimize this
000196  f5c87000          RSB      r0,r8,#0x200
00019a  4404              ADD      r4,r4,r0
;;;455    			
;;;456    			if( sz[0] < OFFLOAD_BUFFER_1SZ)
00019c  9800              LDR      r0,[sp,#0]
00019e  f5b04f60          CMP      r0,#0xe000
0001a2  d207              BCS      |L10.436|
;;;457    			{
;;;458    				i += FlashFileWrite(i,handle,Jpeg_b1,sz[0]);
0001a4  4a15              LDR      r2,|L10.508|
0001a6  4649              MOV      r1,r9
0001a8  4620              MOV      r0,r4
0001aa  9b00              LDR      r3,[sp,#0]
0001ac  f7fffffe          BL       FlashFileWrite
0001b0  4404              ADD      r4,r4,r0
0001b2  e010              B        |L10.470|
                  |L10.436|
;;;459    #ifdef UART_IMG_DUMP
;;;460    				SerComSendArrayUser(Jpeg_b1,sz[0]);
;;;461    #endif
;;;462    			}
;;;463    			else
;;;464    			{
;;;465    				i += FlashFileWrite(i,handle,Jpeg_b1,OFFLOAD_BUFFER_1SZ);//This will automatically end at 512 boundary as it is multiple of 1024
0001b4  f44f4360          MOV      r3,#0xe000
0001b8  4a10              LDR      r2,|L10.508|
0001ba  4649              MOV      r1,r9
0001bc  4620              MOV      r0,r4
0001be  f7fffffe          BL       FlashFileWrite
0001c2  4404              ADD      r4,r4,r0
;;;466    				i += FlashFileWrite(i,handle,Jpeg_b2,sz[0] - OFFLOAD_BUFFER_1SZ);
0001c4  9800              LDR      r0,[sp,#0]
0001c6  f5a04360          SUB      r3,r0,#0xe000
0001ca  4a0d              LDR      r2,|L10.512|
0001cc  4649              MOV      r1,r9
0001ce  4620              MOV      r0,r4
0001d0  f7fffffe          BL       FlashFileWrite
0001d4  4404              ADD      r4,r4,r0
                  |L10.470|
;;;467    #ifdef UART_IMG_DUMP
;;;468    				SerComSendArrayUser(Jpeg_b1,OFFLOAD_BUFFER_1SZ);
;;;469    				SerComSendArrayUser(Jpeg_b2,sz[0] - OFFLOAD_BUFFER_1SZ);
;;;470    #endif
;;;471    			}
;;;472    		}
;;;473    		FlashFileBytesWritten = i;
0001d6  480e              LDR      r0,|L10.528|
0001d8  6004              STR      r4,[r0,#0]  ; FlashFileBytesWritten
;;;474    		FlashCloseFile(handle,seq);//Close File Access
0001da  4648              MOV      r0,r9
0001dc  9902              LDR      r1,[sp,#8]
0001de  f7fffffe          BL       FlashCloseFile
                  |L10.482|
;;;475    		
;;;476    	}
;;;477    	//update sequence and filesize variable
;;;478    	*nseq = seq;
0001e2  9802              LDR      r0,[sp,#8]
0001e4  6030              STR      r0,[r6,#0]
;;;479    	*fsz = i;
0001e6  603c              STR      r4,[r7,#0]
;;;480    	//Report bytes written and sequence number
;;;481    	return err;
0001e8  4628              MOV      r0,r5
;;;482    }
0001ea  e8bd8ffe          POP      {r1-r11,pc}
                          ENDP

0001ee  0000              DCW      0x0000
                  |L10.496|
                          DCD      jpegTotalTime
                  |L10.500|
                          DCD      0x40020000
                  |L10.504|
                          DCD      JpegBuffer
                  |L10.508|
                          DCD      Jpeg_b1
                  |L10.512|
                          DCD      Jpeg_b2
                  |L10.516|
                          DCD      0x40026428
                  |L10.520|
                          DCD      0xabcdef01
                  |L10.524|
                          DCD      imgdebug
                  |L10.528|
                          DCD      FlashFileBytesWritten

                          AREA ||i.DCMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  DCMI_IRQHandler PROC
;;;70     
;;;71     void DCMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;72     {  	   
;;;73     	if (DCMI_GetITStatus(DCMI_IT_FRAME) == 1) 
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       DCMI_GetITStatus
000008  2801              CMP      r0,#1
00000a  d104              BNE      |L11.22|
;;;74     	{		
;;;75     		DCMI_ClearITPendingBit(DCMI_IT_FRAME); 			
00000c  f7fffffe          BL       DCMI_ClearITPendingBit
;;;76     		jpegCaptureDoneITFLG = 1;
000010  2001              MOVS     r0,#1
000012  4901              LDR      r1,|L11.24|
000014  7008              STRB     r0,[r1,#0]
                  |L11.22|
;;;77     	}	
;;;78     }
000016  bd10              POP      {r4,pc}
;;;79     
                          ENDP

                  |L11.24|
                          DCD      jpegCaptureDoneITFLG

                          AREA ||i.disable_clock||, CODE, READONLY, ALIGN=1

                  disable_clock PROC
;;;121    
;;;122    void disable_clock(void)
000000  b510              PUSH     {r4,lr}
;;;123    {
;;;124    	
;;;125    	GPIO_InitTypeDef GPIO_InitStructure;
;;;126    	RCC_ClockSecuritySystemCmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;127    	/* Enable GPIOs clocks */
;;;128    	return;
;;;129    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);			
;;;130    	/* Configure MCO (PA8) */
;;;131    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
;;;132    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;133    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;134    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;135    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;  //UP
;;;136    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;137    }
000008  bd10              POP      {r4,pc}
;;;138    
                          ENDP


                          AREA ||i.enable_clock||, CODE, READONLY, ALIGN=2

                  enable_clock PROC
;;;104    
;;;105    void enable_clock(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;106    {
;;;107    	GPIO_InitTypeDef GPIO_InitStructure;
;;;108    			RCC_ClockSecuritySystemCmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;109    			/* Enable GPIOs clocks */
;;;110    			RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;111    			GPIO_PinAFConfig(GPIOA, GPIO_PinSource8, GPIO_AF_MCO);
000010  2200              MOVS     r2,#0
000012  2108              MOVS     r1,#8
000014  480d              LDR      r0,|L13.76|
000016  f7fffffe          BL       GPIO_PinAFConfig
;;;112    			/* Configure MCO (PA8) */
;;;113    			GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
00001a  f44f7080          MOV      r0,#0x100
00001e  9000              STR      r0,[sp,#0]
;;;114    			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000020  2003              MOVS     r0,#3
000022  f88d0005          STRB     r0,[sp,#5]
;;;115    			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000026  2002              MOVS     r0,#2
000028  f88d0004          STRB     r0,[sp,#4]
;;;116    			GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00002c  2000              MOVS     r0,#0
00002e  f88d0006          STRB     r0,[sp,#6]
;;;117    			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  //UP
000032  2001              MOVS     r0,#1
000034  f88d0007          STRB     r0,[sp,#7]
;;;118    			GPIO_Init(GPIOA, &GPIO_InitStructure);
000038  4669              MOV      r1,sp
00003a  4804              LDR      r0,|L13.76|
00003c  f7fffffe          BL       GPIO_Init
;;;119    			RCC_MCO1Config(RCC_MCO1Source_HSI, RCC_MCO1Div_1);// 16MHZ
000040  2100              MOVS     r1,#0
000042  4608              MOV      r0,r1
000044  f7fffffe          BL       RCC_MCO1Config
;;;120    }
000048  bd1c              POP      {r2-r4,pc}
;;;121    
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      0x40020000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  JpegBuffer
                          %        122880
                  Jpeg_b1
                          %        57344
                  imgdebug
                          %        72
                  cs_flash
                          %        24

                          AREA ||.cmm||, DATA, ALIGN=0

                  Jpeg_b2
                          %        65536

                          AREA ||.data||, DATA, ALIGN=2

                  jpegCaptureTime
                          DCD      0x00000000
                  jpegTotalTime
                          DCD      0x00000000
                  jpegCaptureDoneITFLG
000008  0000              DCB      0x00,0x00
                  click_dly
00000a  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\camdrv.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_camdrv_c_7060df68____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_camdrv_c_7060df68____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_camdrv_c_7060df68____REVSH|
#line 128
|__asm___8_camdrv_c_7060df68____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
